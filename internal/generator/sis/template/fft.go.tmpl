import (
	"github.com/consensys/gnark-crypto/ecc/{{ .Name }}/fr"
	"math/big"
)

// fft64 is generated by gnark-crypto and contains the unrolled code for FFT (DIF) on 64 elements
// equivalent code: r.Domain.FFT(k, fft.DIF, fft.OnCoset(), fft.WithNbTasks(1))
// twiddlesCoset must be pre-computed from twiddles and coset table, see precomputeTwiddlesCoset
func fft64(a []fr.Element,  twiddlesCoset []fr.Element) {

	{{- /* notes: 
		this function can be updated with larger n
		nbSteps must be updated too such as 1 << nbSteps == n
		butterflies and multiplication are separated for size n = 8, must check perf for larger n
	 */}}
	 {{$tIndex := 0}}
	{{ $n := 64}}
	{{ $m := div $n 2}}
	{{ $split := 1}}
	{{ $split = div $split 1}}
	{{- range $step := reverse (iterate 0 6)}} 

		{{- $offset := 0}}
		{{- range $s := iterate 0 $split}}
			{{- range $i := iterate 0 $m}}
				{{- $j := add $i $offset}}
				{{- $k := add $j $m}}
				a[{{$k}}].Mul(&a[{{$k}}], &twiddlesCoset[{{$tIndex}}])
			{{- end}}
			{{- $offset = add $offset $n}}
			{{- $tIndex = add $tIndex 1}}
		{{- end}}

		{{- $offset := 0}}
		{{- range $s := iterate 0 $split}}
			{{- range $i := iterate 0 $m}}
				{{- $j := add $i $offset}}
				{{- $k := add $j $m}}
				fr.Butterfly(&a[{{$j}}], &a[{{$k}}])
			{{- end}}
			{{- $offset = add $offset $n}}
		{{- end}}
		
		{{- $n = div $n 2}}
		{{- $m = div $n 2}}
		{{- $split = mul $split 2}}
	{{- end}}
}

// precomputeTwiddlesCoset precomputes twiddlesCoset from twiddles and coset table
// it then return all elements in the correct order for the unrolled FFT.
func precomputeTwiddlesCoset(generator, shifter fr.Element) []fr.Element {
	toReturn := make([]fr.Element,  63)
	var r, s fr.Element
	e := new(big.Int)
	{{ $n := 64}}
	{{ $m := div $n 2}}
	{{ $split := 1}}
	{{ $split = div $split 1}}
	{{ $j := 0}}
	{{- range $step := reverse (iterate 0 6)}} 
		s = shifter
		for k:=0; k <{{$step}};k++ {
			s.Square(&s)
		}
		
		{{- $offset := 0}}
		{{- range $s := iterate 0 $split}}
			{{- $exp := bitReverse $split $s}}
			{{- if eq $exp 0}}
				toReturn[{{$j}}] = s
			{{- else}}
				r.Exp(generator, e.SetUint64(uint64(1<<{{$step}} * {{$exp}})))
				toReturn[{{$j}}].Mul(&r, &s)
			{{- end}}
			{{- $j = add $j 1}}
		{{- end}}

		{{- $split = mul $split 2}}
	{{- end}}
	return toReturn
}